// Code generated by MockGen. DO NOT EDIT.
// Source: access_authorization_service.go
//
// Generated by this command:
//
//	mockgen -source=access_authorization_service.go -destination=../../tests/domain/mock_access_authorization_service.go -package=domain
//

// Package domain is a generated GoMock package.
package domain

import (
	context "context"
	reflect "reflect"

	domain "github.com/na2na-p/cargohold/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockAccessAuthorizationService is a mock of AccessAuthorizationService interface.
type MockAccessAuthorizationService struct {
	ctrl     *gomock.Controller
	recorder *MockAccessAuthorizationServiceMockRecorder
	isgomock struct{}
}

// MockAccessAuthorizationServiceMockRecorder is the mock recorder for MockAccessAuthorizationService.
type MockAccessAuthorizationServiceMockRecorder struct {
	mock *MockAccessAuthorizationService
}

// NewMockAccessAuthorizationService creates a new mock instance.
func NewMockAccessAuthorizationService(ctrl *gomock.Controller) *MockAccessAuthorizationService {
	mock := &MockAccessAuthorizationService{ctrl: ctrl}
	mock.recorder = &MockAccessAuthorizationServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccessAuthorizationService) EXPECT() *MockAccessAuthorizationServiceMockRecorder {
	return m.recorder
}

// Authorize mocks base method.
func (m *MockAccessAuthorizationService) Authorize(ctx context.Context, operation domain.Operation, userRepo *domain.RepositoryIdentifier, oid domain.OID) (domain.AuthorizationResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Authorize", ctx, operation, userRepo, oid)
	ret0, _ := ret[0].(domain.AuthorizationResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Authorize indicates an expected call of Authorize.
func (mr *MockAccessAuthorizationServiceMockRecorder) Authorize(ctx, operation, userRepo, oid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authorize", reflect.TypeOf((*MockAccessAuthorizationService)(nil).Authorize), ctx, operation, userRepo, oid)
}

// CanAccess mocks base method.
func (m *MockAccessAuthorizationService) CanAccess(ctx context.Context, userRepo *domain.RepositoryIdentifier, oid domain.OID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CanAccess", ctx, userRepo, oid)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CanAccess indicates an expected call of CanAccess.
func (mr *MockAccessAuthorizationServiceMockRecorder) CanAccess(ctx, userRepo, oid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanAccess", reflect.TypeOf((*MockAccessAuthorizationService)(nil).CanAccess), ctx, userRepo, oid)
}
